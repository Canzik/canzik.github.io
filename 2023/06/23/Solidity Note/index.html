<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="author" content="Canzik"><meta name="desciption" content="世界上只有一种真正的英雄主义，那就是在认清生活的真相后依然热爱生活。"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Solidity Note</title><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/carbon.css"><script defer="defer" src="//cdn.jsdelivr.net/jquery/2.1.4/jquery.min.js"></script><script defer="defer" src="//cdn.jsdelivr.net/jquery.pjax/1.9.5/jquery.pjax.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.css" type="text/css" media="screen"><script defer="defer" type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>var performFancybox = true;</script><script>var doRenderMath = 'mathjax'</script><!--mathjax config similar to math.stackexchange--><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: true
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script defer="defer" src="/js/carbon.js"></script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="container"><div id="banner"><h1 id="site-title"><a href="/">Canzik's Blog</a></h1><p id="site-subtitle"></p></div><div id="content"><div class="meta"><h2 class="article-title"><a href="/2023/06/23/Solidity%20Note">Solidity Note</a></h2><div class="article-date"><a href="javascript:void(0);" class="extra-switch">2023-06-23</a></div></div><div class="extra"><span class="Tags">Tags: <a href="/tags/Blockchain/">Blockchain</a>.</span></div><div class="extra"><span class="Categories">Categories: <a href="/categories/notes/">notes</a>.</span></div><div class="article-content"><div class="gallery"></div><p>粗浅地学习了一下solidity</p>
<span id="more"></span>
<h2 id="简单的智能合约">简单的智能合约</h2>
<p>Solidity中智能合约的含义就是一组代码（它的 <em>功能</em> )和数据（它的 <em>状态</em>）的集合，并且它们是位于以太坊区块链的一个特定地址上的</p>
<p><strong>存储合约示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;  //声明版本范围</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;  //uint 256位无符号整数</span><br><span class="line"></span><br><span class="line">    function set(uint x) public &#123;</span><br><span class="line">        storedData = x;   //solidity中不需要用this.访问</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>set</code>：修改变量storeData的值</p>
<p><code>get</code>：检索变量storeData的值</p>
<p>这个简单的合约允许任何人在合约中存储一个单独的数字，并且这个数字可以被任何人访问，且没有可行的方法阻止这个数字的发布</p>
<p>****货币合约（Subcurrency）示例****</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    // 关键字“public”让这些变量可以从外部读取    </span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    // 轻客户端可以通过事件针对变化作出高效的反应    </span><br><span class="line">    event Sent(address from, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    // 这是构造函数，只有当合约创建时运行    </span><br><span class="line">    constructor() &#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address receiver, uint amount) public &#123;</span><br><span class="line">        require(msg.sender == minter);</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   // Errors allow you to provide information about</span><br><span class="line">   // why an operation failed. They are returned</span><br><span class="line">   // to the caller of the function.    </span><br><span class="line">   error InsufficientBalance(uint requested, uint available);</span><br><span class="line"></span><br><span class="line">    function send(address receiver, uint amount) public &#123;</span><br><span class="line">        if (amount &gt; balances[msg.sender])</span><br><span class="line">            revert InsufficientBalance(&#123;</span><br><span class="line">                requested: amount,</span><br><span class="line">                available: balances[msg.sender]</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        emit Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>address public minter</code>：</p>
<p>address是个160位的值，且不允许任何算数操作。关键字<code>public</code>自动生成一个函数，允许在此合约之外访问这个状态变量的当前值。public会由编译器自动生成一段函数，代码大致如下（暂时忽略
external 和 view）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function minter() external view returns (address) &#123; return minter; &#125;</span><br></pre></td></tr></table></figure>
<p>在使用public后再加上这段代码会造成冲突，会出现同名的一个函数和一个变量</p>
<p><code>mapping (address =&gt; uint) public balances</code>：</p>
<p>mapping类型，将address映射为无符号整数（uint）。在使用mapping时，要么记住你添加到mapping中的数据（使用列表或更高级的数据类型会更好），要么在不需要键列表或值列表的上下文中使用它。这里由public生成的函数要更加复杂一点，大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function balances(address account) external view returns (uint) &#123;</span><br><span class="line">    return balances[account];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以很轻松的查询账户的余额</p>
<p><code>event Sent(address from, address to, uint amount)</code>：</p>
<p>这行声明了一个所谓的“事件（event）”，它会在 <code>send</code> 函数的最后一行被发出。用户界面（当然也包括服务器应用程序）可以监听区块链上正在发送的事件，而不会花费太多成本。一旦它被发出，监听该事件的listener都将收到通知。而所有的事件都包含了 <code>from</code> ， <code>to</code> 和 <code>amount</code> 三个参数，可方便追踪交易。</p>
<p>为了监听这个事件，你可以使用如下JavaScript代码， Coin 是通过 web3.js
创建的合约对象  :</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Coin</span>.<span class="title class_">Sent</span>().<span class="title function_">watch</span>(&#123;&#125;, <span class="string">&#x27;&#x27;</span>,<span class="keyword">function</span>(<span class="params">error, result</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Coin transfer: &quot;</span> + result.<span class="property">args</span>.<span class="property">amount</span> +</span><br><span class="line">            <span class="string">&quot; coins were sent from &quot;</span> + result.<span class="property">args</span>.<span class="property">from</span> +</span><br><span class="line">            <span class="string">&quot; to &quot;</span> + result.<span class="property">args</span>.<span class="property">to</span> + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Balances now:\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Sender: &quot;</span> + <span class="title class_">Coin</span>.<span class="property">balances</span>.<span class="title function_">call</span>(result.<span class="property">args</span>.<span class="property">from</span>) +</span><br><span class="line">            <span class="string">&quot;Receiver: &quot;</span> + <span class="title class_">Coin</span>.<span class="property">balances</span>.<span class="title function_">call</span>(result.<span class="property">args</span>.<span class="property">to</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><del>搞不懂event，菜的扣脚</del></p>
<p><code>constructor</code>：</p>
<p>创建合约期间运行的构造函数，不能在创建后调用。此合约中构造函数用来永久存储创建合约的人的地址<code>msg</code>。<code>msg.sender</code>始终记录当前（外部）函数调用是来自于哪一个地址</p>
<p><code>mint</code>：</p>
<p>mint函数用来新发行一定的币到一个新地址。<code>require</code>用来检查某些条件，不满足就会回推所有的状态变化。在这个合约中，<code>require(msg.sender == minter)</code>确保只有合约创建者可以调用<code>mint</code>。当<code>balances[receiver] += amount</code>的值大于<code>uint</code>（2**256-1），称为溢出交易，溢出交易将被还原</p>
<p><code>error</code>：</p>
<p>描述错误信息，一般和<code>revert</code>一起使用。<code>revert</code>语句无条件地中止执行并回退所有的变化，类似于 <code>require</code>函数，它也同样允许你提供一个错误的名称和额外的数据，这些额外数据将提供给调用者(并最终提供给前端应用程序或区块资源管理器）。error是一个专门用来返回错误，并且可以自定义返回内容的类型</p>
<p><code>send</code>：</p>
<p>进行交易的函数。此合约中先判断发送者的账户上是否有足够的余额，余额不足用<code>revert</code>语句中止并回退。余额足够则进行账户的交易。交易结束后，使用<code>emit</code>关键字触发事件</p>
<p><code>~~emit</code>和<code>evnet</code>都不是很懂~~</p>
<h2 id="knowledge-point">Knowledge point</h2>
<p><strong>状态变量、局部变量、全局变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract SolidityTest &#123;</span><br><span class="line">   uint storedData; // 状态变量</span><br><span class="line">   constructor() public &#123;</span><br><span class="line">      storedData = 10;   </span><br><span class="line">   &#125;</span><br><span class="line">   function getResult() public view returns(uint)&#123;</span><br><span class="line">      uint a = 1; // 局部变量</span><br><span class="line">      uint b = 2;</span><br><span class="line">      uint result = a + b;</span><br><span class="line">      return result; // 访问局部变量</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>状态变量：变量值永久保存在合约存储空间中的变量</li>
<li>局部变量：变量值仅在函数执行过程中有效的变量，函数退出后，变量无效</li>
<li>全局变量：全局工作区中存在的特殊变量，提供有关区块链和交易属性的信息</li>
</ul>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>blockhash(uint blockNumber) returns (bytes32)</td>
<td>给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</td>
</tr>
<tr class="even">
<td>block.coinbase (address payable)</td>
<td>当前区块矿工的地址</td>
</tr>
<tr class="odd">
<td>block.difficulty (uint)</td>
<td>当前区块的难度</td>
</tr>
<tr class="even">
<td>block.gaslimit (uint)</td>
<td>当前区块的gaslimit</td>
</tr>
<tr class="odd">
<td>block.number (uint)</td>
<td>当前区块的number</td>
</tr>
<tr class="even">
<td>block.timestamp (uint)</td>
<td>当前区块的时间戳，为unix纪元以来的秒</td>
</tr>
<tr class="odd">
<td>gasleft() returns (uint256)</td>
<td>剩余 gas</td>
</tr>
<tr class="even">
<td>msg.data (bytes calldata)</td>
<td>完成 calldata</td>
</tr>
<tr class="odd">
<td>msg.sender (address payable)</td>
<td>消息发送者 (当前 caller)</td>
</tr>
<tr class="even">
<td>msg.sig (bytes4)</td>
<td>calldata的前四个字节 (function identifier)</td>
</tr>
<tr class="odd">
<td>msg.value (uint)</td>
<td>当前消息的wei值</td>
</tr>
<tr class="even">
<td>now (uint)</td>
<td>当前块的时间戳</td>
</tr>
<tr class="odd">
<td>tx.gasprice (uint)</td>
<td>交易的gas价格</td>
</tr>
<tr class="even">
<td>tx.origin (address payable)</td>
<td>交易的发送方</td>
</tr>
</tbody>
</table>
<p><strong>变量作用域</strong></p>
<ul>
<li><strong>Public</strong> –
公共状态变量可以在内部访问，也可以通过消息访问。对于公共状态变量，将生成一个自动getter函数。</li>
<li><strong>Internal</strong> –
内部状态变量只能从当前合约或其派生合约内访问。</li>
<li><strong>Private</strong> –
私有状态变量只能从当前合约内部访问，派生合约内不能访问。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">   uint public data = 30;</span><br><span class="line">   uint internal iData= 10;</span><br><span class="line"></span><br><span class="line">   function x() public returns (uint) &#123;</span><br><span class="line">      data = 3; // 内部访问</span><br><span class="line">      return data;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Caller &#123;</span><br><span class="line">   C c = new C();</span><br><span class="line">   function f() public view returns (uint) &#123;</span><br><span class="line">      return c.data(); // 外部访问</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract D is C &#123;</span><br><span class="line">   uint storedData; // 状态变量</span><br><span class="line"></span><br><span class="line">   function y() public returns (uint) &#123;</span><br><span class="line">      iData = 3; // 派生合约内部访问</span><br><span class="line">      return iData;</span><br><span class="line">   &#125;</span><br><span class="line">   function getResult() public view returns(uint)&#123;</span><br><span class="line">      uint a = 1; // 局部变量</span><br><span class="line">      uint b = 2;</span><br><span class="line">      uint result = a + b;</span><br><span class="line">      return storedData; // 访问状态变量</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>条件运算符</strong></p>
<p><code>?:</code>：如果条件为真？则取值X：否则值Y</p>
<aside>
<p>💡 example:<code>a &gt; b? a: b</code></p>
</aside>
<p><strong>循环语句</strong></p>
<p>与c类似</p>
<p><strong>条件语句</strong></p>
<p>与c类似</p>
<p><strong>引用类型/复合数据类型</strong></p>
<ul>
<li>数组(字符串与bytes是特殊的数组，所以也是引用类型)</li>
<li>struct（结构体）</li>
<li>map（映射）</li>
</ul>
<p>这些类型涉及到的数据量较大，复制它们可能要消耗大量Gas，非常昂贵，所以使用它们时，必须考虑存储位置，例如，是保存在内存中，还是在EVM存储区中</p>
<p><strong>数据位置</strong></p>
<p><code>Storage（存储）</code>：</p>
<p>存储永久数据，该数据可以被合约中所有函数访问。可以把它视为硬盘数据，所有数据都永久存储。因其数据存储的持久性，故成本较高</p>
<p><code>Memory（内存）</code>：</p>
<p>临时数据，比Storage便宜。它只能在函数中访问，函数执行完毕，它的内容就会被丢弃</p>
<p><code>Calldata</code>：</p>
<p>不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。Calladata也是外部函数的参数的默认位置</p>
<p><code>Stack（堆栈）</code>：</p>
<p>EVM维护的非持久性数据，EVM使用堆栈数据位置在执行期间加载变量。最多有1024个级别的限制</p>
<aside>
<p>💡 显示标记变量的位置：<code>数据类型 数据位置 变量名</code></p>
</aside>
<p><strong>变量数据位置规则</strong></p>
<ul>
<li>状态变量：存储在存储区中。此外，不能显式标记状态变量的位置</li>
<li>函数参数与返回值：存储在内存中</li>
<li>局部变量：值类型存储在内存中<code>如uint,bool,address</code>，引用类型<code>数组，struct，map</code>需要显式地指定数据位置</li>
<li>外部函数的参数：存储在Calldata中</li>
</ul>
<p><strong>枚举（Enum）</strong></p>
<p>枚举将一个变量的取值限制为几个预定义值中的一个。精确使用枚举类型有助于减少代码中的bug</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">   enum FreshJuiceSize&#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">   FreshJuiceSize choice;</span><br><span class="line">   FreshJuiceSize constant defaultChoice = FreshJuiceSize.MEDIUM;</span><br><span class="line"></span><br><span class="line">   function setLarge() public &#123;</span><br><span class="line">      choice = FreshJuiceSize.LARGE;</span><br><span class="line">   &#125;</span><br><span class="line">   function getChoice() public view returns (FreshJuiceSize) &#123;</span><br><span class="line">      return choice;</span><br><span class="line">   &#125;</span><br><span class="line">   function getDefaultChoice() public pure returns (uint) &#123;</span><br><span class="line">      return uint(defaultChoice);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结构体（Struct）</strong></p>
<p>与C类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">   struct Book &#123; </span><br><span class="line">      string title;</span><br><span class="line">      string author;</span><br><span class="line">      uint book_id;</span><br><span class="line">   &#125;</span><br><span class="line">   Book book;</span><br><span class="line"></span><br><span class="line">   function setBook() public &#123;</span><br><span class="line">      book = Book(&#x27;Learn Java&#x27;, &#x27;TP&#x27;, 1);</span><br><span class="line">   &#125;</span><br><span class="line">   function getBookId() public view returns (uint) &#123;</span><br><span class="line">      return book.book_id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>映射（mapping）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(_KeyType =&gt; _ValueType)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_KeyType</code> ：可以是任何内置类型，或者bytes和字符串。不允许使用引用类型或复杂对象</li>
<li><code>_ValueType</code> ： 可以是任何类型</li>
</ul>
<p>注意</p>
<ul>
<li>映射的数据位置(data location)只能是storage，通常用于状态变量</li>
<li>映射可以标记为public，Solidity 自动为它创建getter</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract LedgerBalance &#123;</span><br><span class="line">   mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">   function updateBalance(uint newBalance) public &#123;</span><br><span class="line">      balances[msg.sender] = newBalance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Updater &#123;</span><br><span class="line">   function updateBalance() public returns (uint) &#123;</span><br><span class="line">      LedgerBalance ledgerBalance = new LedgerBalance();</span><br><span class="line">      ledgerBalance.updateBalance(10);</span><br><span class="line">      return ledgerBalance.balances(address(this));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对示例代码写一点自己的理解：</p>
<p>address是不可被运算的数据类型，因此需要map映射为uint，再参与运算</p>
<p><strong>类型转换</strong></p>
<p>可以使用构造函数语法，显式地将数据类型转换为另一种类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int8 y = -3;</span><br><span class="line">uint x = uint(y);</span><br><span class="line">//Now x = 0xfffff..fd == 在256bit长度的格式下，-3的补码表示</span><br></pre></td></tr></table></figure>
<p>转换成更小的类型，会丢失高位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 a = 0x12345678;</span><br><span class="line">uint16 b = uint16(a); // b = 0x5678</span><br></pre></td></tr></table></figure>
<p>转换成更大的类型，将向左侧添加填充位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint16 a = 0x1234;</span><br><span class="line">uint32 b = uint32(a); // b = 0x00001234</span><br></pre></td></tr></table></figure>
<p>转换到更小的字节类型，会丢失后面数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">bytes1 b = bytes1(a); // b = 0x12</span><br></pre></td></tr></table></figure>
<p>转换为更大的字节类型时，向右添加填充位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">bytes4 b = bytes4(a); // b = 0x12340000</span><br></pre></td></tr></table></figure>
<p>只有当字节类型和int类型大小相同时，才可以进行转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bytes2 a = 0x1234;</span><br><span class="line">uint32 b = uint16(a); // b = 0x00001234</span><br><span class="line">uint32 c = uint32(bytes4(a)); // c = 0x12340000</span><br><span class="line">uint8 d = uint8(uint16(a)); // d = 0x34</span><br><span class="line">uint8 e = uint8(bytes1(a)); // e = 0x12</span><br></pre></td></tr></table></figure>
<p>把整数赋值给整型时，不能超出范围，发生截断，否则会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint8 a = 12; // no error</span><br><span class="line">uint32 b = 1234; // no error</span><br><span class="line">uint16 c = 0x123456; // error, 有截断，变为 0x3456</span><br></pre></td></tr></table></figure>
<p><strong>以太单位</strong></p>
<p>Solidity
中，以太币的单位可以使用<code>wei</code>、<code>finney</code>、<code>szabo</code>或<code>ether</code>表示。</p>
<p>最小的单位是<code>wei</code>。<code>1e12</code>表示<code>1 x 10^12</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert(1 wei == 1);</span><br><span class="line">assert(1 szabo == 1e12);</span><br><span class="line">assert(1 finney == 1e15);</span><br><span class="line">assert(1 ether == 1e18);</span><br></pre></td></tr></table></figure>
<p><strong>函数</strong></p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function function-name(parameter-list) scope returns() &#123;</span><br><span class="line">   //语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>return语句可以返回多个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">   function getResult() public view returns(uint product, uint sum)&#123;</span><br><span class="line">      uint a = 1; // 局部变量</span><br><span class="line">      uint b = 2;</span><br><span class="line">      product = a * b; // 使用返回参数返回值</span><br><span class="line">      sum = a + b; // 使用返回参数返回值</span><br><span class="line"></span><br><span class="line">      // 也可以使用return返回多个值</span><br><span class="line">      // return(a*b, a+b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修饰符：</p>
<p>函数修饰符用于修改函数的行为。例如，向函数添加条件限制。</p>
<p>修饰符定义中出现特殊符号<code>_</code>
的地方，用于插入函数体。如果在调用此函数时，满足了修饰符的条件，则执行该函数，否则将抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Owner &#123;</span><br><span class="line">   address owner;</span><br><span class="line"></span><br><span class="line">   constructor() public &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 定义修饰符 onlyOwner 不带参数</span><br><span class="line">   modifier onlyOwner &#123;</span><br><span class="line">      require(msg.sender == owner);</span><br><span class="line">      _;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 定义修饰符 costs 带参数</span><br><span class="line">   modifier costs(uint price) &#123;</span><br><span class="line">      if (msg.value &gt;= price) &#123;</span><br><span class="line">         _;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is Owner &#123;</span><br><span class="line">   mapping (address =&gt; bool) registeredAddresses;</span><br><span class="line">   uint price;</span><br><span class="line"></span><br><span class="line">   constructor(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">   // 使用修饰符 costs</span><br><span class="line">   function register() public payable costs(price) &#123;</span><br><span class="line">      registeredAddresses[msg.sender] = true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 使用修饰符 onlyOwner</span><br><span class="line">   function changePrice(uint _price) public onlyOwner &#123;</span><br><span class="line">      price = _price;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>onlyOwner</code>和<code>costs</code>是修饰符</p>
<p>view(视图)函数：</p>
<p>View(视图)函数不会修改状态。如果函数中存在以下语句，则被视为修改状态，编译器将抛出警告。</p>
<ul>
<li>修改状态变量。</li>
<li>触发事件。</li>
<li>创建合约。</li>
<li>使用<code>selfdestruct</code>。</li>
<li>发送以太。</li>
<li>调用任何不是视图函数或纯函数的函数</li>
<li>使用底层调用</li>
<li>使用包含某些操作码的内联程序集。</li>
</ul>
<p>Getter方法是默认的视图函数。声明视图函数，可以在函数声明里，添加<code>view</code>关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">   function getResult() public view returns(uint product, uint sum)&#123;</span><br><span class="line">      uint a = 1; // 局部变量</span><br><span class="line">      uint b = 2;</span><br><span class="line">      product = a * b;</span><br><span class="line">      sum = a + b; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pure(纯)函数：</p>
<p>Pure(纯)函数<strong>不读取</strong>或修改状态。如果函数中存在以下语句，则被视为读取状态，编译器将抛出警告。</p>
<ul>
<li>读取状态变量。</li>
<li>访问 <code>address(this).balance</code> 或 <code>&lt;address&gt;.balance</code></li>
<li>访问任何区块、交易、msg等特殊变量(msg.sig 与 msg.data
允许读取)。</li>
<li>调用任何不是纯函数的函数。</li>
<li>使用包含特定操作码的内联程序集。</li>
</ul>
<p>如果发生错误，纯函数可以使用<code>revert()</code>和<code>require()</code>函数来还原潜在的状态更改。</p>
<p>声明纯函数，可以在函数声明里，添加<code>pure</code>关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">   function getResult() public pure returns(uint product, uint sum)&#123;</span><br><span class="line">      uint a = 1; </span><br><span class="line">      uint b = 2;</span><br><span class="line">      product = a * b;</span><br><span class="line">      sum = a + b; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fallback(回退)函数：</p>
<p>fallback(回退) 函数是合约中的特殊函数。它有以下特点</p>
<ul>
<li>当合约中不存在的函数被调用时，将调用fallback函数。</li>
<li>被标记为外部函数。</li>
<li>它没有名字。</li>
<li>它没有参数。</li>
<li>它不能返回任何东西。</li>
<li>每个合约定义一个fallback函数。</li>
<li>如果没有被标记为<code>payable</code>，则当合约收到无数据的以太币转账时，将抛出异常。</li>
</ul>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 没有名字，没有参数，不返回，标记为external，可以标记为payable</span><br><span class="line">function() external &#123;</span><br><span class="line">    // statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的示例展示了合约中的回退函数概念。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">   uint public x ;</span><br><span class="line">   function() external &#123; x = 1; &#125;    </span><br><span class="line">&#125;</span><br><span class="line">contract Sink &#123;</span><br><span class="line">   function() external payable &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Caller &#123;</span><br><span class="line"></span><br><span class="line">   function callTest(Test test) public returns (bool) &#123;</span><br><span class="line">      (bool success,) = address(test).call(abi.encodeWithSignature(&quot;nonExistingFunction()&quot;));</span><br><span class="line">      require(success);</span><br><span class="line">      // test.x 是 1</span><br><span class="line"></span><br><span class="line">      address payable testPayable = address(uint160(address(test)));</span><br><span class="line"></span><br><span class="line">      // 发送以太测试合同,</span><br><span class="line">      // 转账将失败，也就是说，这里返回false。</span><br><span class="line">      return (testPayable.send(2 ether));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function callSink(Sink sink) public returns (bool) &#123;</span><br><span class="line">      address payable sinkPayable = address(sink);</span><br><span class="line">      return (sinkPayable.send(2 ether));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数重载</strong></p>
<p>同一个作用域内，相同函数名可以定义多个函数。这些函数的参数(参数类型或参数数量)必须不一样。仅仅是返回值不一样不被允许</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">   function getSum(uint a, uint b) public pure returns(uint)&#123;      </span><br><span class="line">      return a + b;</span><br><span class="line">   &#125;</span><br><span class="line">   function getSum(uint a, uint b, uint c) public pure returns(uint)&#123;      </span><br><span class="line">      return a + b + c;</span><br><span class="line">   &#125;</span><br><span class="line">   function callSumWithTwoArguments() public pure returns(uint)&#123;</span><br><span class="line">      return getSum(1,2);</span><br><span class="line">   &#125;</span><br><span class="line">   function callSumWithThreeArguments() public pure returns(uint)&#123;</span><br><span class="line">      return getSum(1,2,3);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0: uint256: 3</span><br><span class="line">//0: uint256: 6</span><br></pre></td></tr></table></figure>
<p><strong>数学函数</strong></p>
<p>Solidity提供内置的数学函数，如：</p>
<ul>
<li><code>addmod(uint x, uint y, uint k) returns (uint)</code> 计算(x +
y) % k，计算中，以任意精度执行加法，且不限于2^256大小。</li>
<li><code>mulmod(uint x, uint y, uint k) returns (uint)</code> 计算(x *
y) % k，计算中，以任意精度执行乘法，且不限于2^256大小。</li>
</ul>
<p><strong>加密函数</strong></p>
<p>Solidity 提供了常用的加密函数。以下是一些重要函数：</p>
<ul>
<li><code>keccak256(bytes memory) returns (bytes32)</code> 计算输入的Keccak-256散列。</li>
<li><code>sha256(bytes memory) returns (bytes32)</code> 计算输入的SHA-256散列。</li>
<li><code>ripemd160(bytes memory) returns (bytes20)</code> 计算输入的RIPEMD-160散列。</li>
<li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code> 从椭圆曲线签名中恢复与公钥相关的地址，或在出错时返回零。函数参数对应于签名的ECDSA值:
r – 签名的前32字节; s: 签名的第二个32字节; v:
签名的最后一个字节。这个方法返回一个地址。</li>
</ul>
<p><strong>合约继承</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>构造函数</strong></p>
<p>构造函数是使用<code>construct</code>关键字声明的特殊函数，用于初始化合约的状态变量。合约中构造函数是可选的，可以省略。</p>
<p>构造函数有以下重要特性：</p>
<ul>
<li>一个合约只能有一个构造函数。</li>
<li>构造函数在创建合约时执行一次，用于初始化合约状态。</li>
<li>在执行构造函数之后，合约最终代码被部署到区块链。合约最终代码包括公共函数和可通过公共函数访问的代码。构造函数代码或仅由构造函数使用的任何内部方法不包括在最终代码中。</li>
<li>构造函数可以是公共的，也可以是内部的。</li>
<li>内部构造函数将合约标记为抽象合约。</li>
<li>如果没有定义构造函数，则使用默认构造函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">   constructor() public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果基合约具有带参数的构造函数，则每个派生/继承的合约也都必须包含参数。</li>
<li>可以使用下面的方法直接初始化基构造函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">   uint data;</span><br><span class="line">   constructor(uint _data) public &#123;</span><br><span class="line">      data = _data;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Derived is Base (5) &#123;</span><br><span class="line">   constructor() public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用以下方法间接初始化基构造函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">   uint data;</span><br><span class="line">   constructor(uint _data) public &#123;</span><br><span class="line">      data = _data;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Derived is Base &#123;</span><br><span class="line">   constructor(uint _info) Base(_info * _info) public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不允许直接或间接地初始化基合约构造函数。</li>
<li>如果派生合约没有将参数传递给基合约构造函数，则派生合约将成为抽象合约。</li>
</ul>
<p><strong>抽象合约</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Calculator &#123;</span><br><span class="line">   function getResult() public view returns(uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test is Calculator &#123;</span><br><span class="line">   function getResult() public view returns(uint) &#123;</span><br><span class="line">      uint a = 1;</span><br><span class="line">      uint b = 2;</span><br><span class="line">      uint result = a + b;</span><br><span class="line">      return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口</strong></p>
<p>接口类似于抽象合约，使用<code>interface</code>关键字创建，接口只能包含抽象函数，不能包含函数实现。以下是接口的关键特性：</p>
<ul>
<li>接口的函数只能是外部类型。</li>
<li>接口不能有构造函数。</li>
<li>接口不能有状态变量。</li>
<li>接口可以包含enum、struct定义，可以使用<code>interface_name.</code>访问它们。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">interface Calculator &#123;</span><br><span class="line">   function getResult() external view returns(uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test is Calculator &#123;</span><br><span class="line">   constructor() public &#123;&#125;</span><br><span class="line">   function getResult() external view returns(uint)&#123;</span><br><span class="line">      uint a = 1; </span><br><span class="line">      uint b = 2;</span><br><span class="line">      uint result = a + b;</span><br><span class="line">      return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>库</strong></p>
<p>Solidity中，对库的使用有一定的限制。以下是库的主要特征。</p>
<ul>
<li>如果库函数不修改状态，则可以直接调用它们。这意味着<a
target="_blank" rel="noopener" href="https://www.qikegu.com/docs/4963">纯函数</a>或<a
target="_blank" rel="noopener" href="https://www.qikegu.com/docs/4961">视图函数</a>只能从库外部调用。</li>
<li>库不能被销毁，因为它被认为是无状态的。</li>
<li>库不能有状态变量。</li>
<li>库不能继承任何其他元素。</li>
<li>库不能被继承。</li>
</ul>
<p>使用library声明，使用<code>&lt;library_name&gt;.&lt;func_name&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">   function indexOf(uint[] storage self, uint value) public view returns (uint) &#123;</span><br><span class="line">      for (uint i = 0; i &lt; self.length; i++) if (self[i] == value) return i;</span><br><span class="line">      return uint(-1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Test &#123;</span><br><span class="line">   uint[] data;</span><br><span class="line">   constructor() public &#123;</span><br><span class="line">      data.push(1);</span><br><span class="line">      data.push(2);</span><br><span class="line">      data.push(3);</span><br><span class="line">      data.push(4);</span><br><span class="line">      data.push(5);</span><br><span class="line">   &#125;</span><br><span class="line">   function isValuePresent() external view returns(uint)&#123;</span><br><span class="line">      uint value = 4;</span><br><span class="line"></span><br><span class="line">      // 使用库函数搜索数组中是否存在值</span><br><span class="line">      uint index = Search.indexOf(data, value);</span><br><span class="line">      return index;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>****使用汇编(Assembly)代码****</p>
<p>使用内联汇编，可以在solidity中嵌入汇编代码，使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assembly&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>事件</strong></p>
<p>事件是智能合约发出的信号。智能合约的前端UI，例如，DApps、web.js，或者任何与Ethereum
JSON-RPC
API连接的东西，都可以侦听这些事件。事件可以被索引，以便以后可以搜索事件记录。</p>
<blockquote>
<p>事件在区块链中的存储</p>
<p>区块链是一个区块链表，这些块的内容基本上是交易记录。每个交易都有一个附加的交易日志，事件结果存放在交易日志里。合约发出的事件，可以使用合约地址访问。</p>
</blockquote>
<p>Solidity中可以使用<code>event</code>关键字(在用法上类似于<code>function</code>关键字)。然后可以在函数中使用<code>emit</code>关键字触发事件</p>
<p>创建合约并发出一个事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Counter &#123;</span><br><span class="line">    uint256 public count = 0;</span><br><span class="line"></span><br><span class="line">    event Increment(address who);   // 声明事件</span><br><span class="line"></span><br><span class="line">    function increment() public &#123;</span><br><span class="line">        emit Increment(msg.sender); // 触发事件</span><br><span class="line">        count += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><nav class="pagination"><a id="left-navigator" href="/2023/07/11/AES%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%80%97%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98/">AES相关功耗分析问题</a><a id="right-navigator" href="/2023/02/05/%E8%AE%B0%E4%B8%80%E4%B8%AANTRU%E6%9D%BF%E5%AD%90%E9%A2%98/">记一个NTRU板子题</a></nav></div><nav id="footer"><ul id="footer-links"><li><a href="/about" class="zn">关于</a></li><li><a href="/archives" class="zn">所有文章</a></li></ul></nav></div></body></html>